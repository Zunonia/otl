이것은 mercurial repository입니다. Subversion을 사용해보신 분들을 기준으로
간단하게 설명하면, SVN은 중앙집중형 저장소 모델로 하나의 저장소 <-> 다수의
working copy만으로 이루어지는 형태를 띠지만 이것은 각 저장소가 독립적으로
운영되며 서로 동기화하는 기능을 갖추고 있습니다.

SVN의 사용법과 비교하면,

svn checkout REPOS_PATH DEST_DIR            hg clone REPOS_PATH DEST_DIR
svn update                                  hg pull & hg update
svn commit                                  hg commit & hg push

와 같이 이루어집니다.

SVN은 항상 원격 저장소를 기준으로 작업이 이루어지지만 mercurial(이하 hg로
표기)은 clone하는 순간 로컬에 저장소가 통째로 복사되고 여기서
update/commit을 하면 로컬 저장소에만 반영됩니다. 이것을 원격 저장소에
반영하려면 hg push로 밀어넣어주어야 하고, 원격 저장소에서 변경된 내용을
가져오려면 hg pull로 당겨와야 합니다.

저장소끼리 동기화가 이루어질 때 conflict나는 부분이 있더라도 자동으로
branch된 상태가 되고 해당 저장소를 사용하는 사람이 update를 할 때 어떻게
merge할 것인지 물어보게 됩니다. hg pull을 해서 원격저장소 내용을 가져와도
당장은 working copy에 반영되지 않고, 반드시 hg update를 해주어야만 반영되는
특징이 있으며 이때 적절한 merge 작업을 하게 됩니다. (즉, 원격저장소 내용 +
로컬저장소 내용 + working copy 3가지를 놓고 합칩니다.)

SVN은 반드시 중앙집중형 모델로만 개발이 가능하지만 hg는 그런 방식으로
사용할 수도 있고 다른 형태의 개발 모델을 도입할 수 있다는 장점이 있습니다.
이를 테면 각 개발자가 자신의 저장소를 독립적으로 호스팅해서 다른 사람들을
개발에 참여시킨 후 그것을 중앙저장소에 반영하기 전에 자신이 코드 품질을
완성시켜 중앙저장소에는 항상 깨끗한 코드만 유지되게 한다든지 하는
오픈소스에 매우 적합한 형태의 소스 관리가 가능합니다. 또한 무엇보다 SVN에
비해 월등히 빠른 속도와 작은 repository 용량을 자랑합니다.

로컬저장소가 있음으로써 생기는 장점은 오프라인일 때도 혼자 자신만의
저장소에서 작업을 하다가 나중에 온라인이 되었을 때 한꺼번에 push하는 식으로
개발 과정에서 좀더 유연성으 확보할 수 있다는 점도 들 수 있습니다.

다만 SVN에 비해 단점은, 저장소 내의 한 디렉토리나 파일만 체크아웃하는 것이
불가능하고 항상 저장소를 통째로 clone해야 한다는 점이 있습니다.

/* vim: set ts=8 sts=4 sw=4 et: */
